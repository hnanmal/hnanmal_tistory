# 다이나모 코드의 추상화 수준을 높여가는 방법

---

다이나모로 프로그래밍을 하는 것의 장점은 무엇일까요?

REPL처럼 개별 노드 별로 실행결과를 반환해서 보여주니 코드 작성 후의 피드백이 빠르다는 점, 그리고 필요한 경우엔 코드에서 다루는  형상을 같이 보면서 작업할 수 있기에 편리합니다.

그런데 간단한 코드를 짜는 것은 어렵지 않지만, 코드를 작성하다 보면 사람은 욕심이 생깁니다.

조금더 추상화 된, 조금더 제너럴 하게 동작할 수 있는 코드로 바꾸고 싶어집니다.

오늘은 그 추상화 수준을 높여가는 기본적인 방법에 대해 말하겠습니다.

먼저 언제나 처럼, 레빗 샘플 파일을 열어볼까요?

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%A9%20%E1%84%8F%200a59b/Untitled.png)

## 벽체 하나의 볼륨을 산출하는 코드

샘플 파일을 열고나서, 다이나모도 실행해 줍니다.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%A9%20%E1%84%8F%200a59b/Untitled%201.png)

오늘 해볼 것은 벽체의 체적 값을 찾아내는 프로그램을 작성하는 것입니다. 가장 기본적으로 떠올릴 수 있는 코드는, 내가 선택한 하나의 벽체에 대한 체적을 가져오는 코드겠죠.

위 그림처럼 먼저 Select Model Element  노드를 배치하고 Select 버튼을 눌러보겠습니다.

그런 다음 레빗 화면에서 벽체를 하나 클릭하면, 다이나모 내부로 선택한 객체가 소환됩니다.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%A9%20%E1%84%8F%200a59b/Untitled%202.png)

그 다음은 벽 객체가 갖고있는 속성 중 하나인 “Volume” 에 할당된 값을 가져오기만 하면 됩니다.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%A9%20%E1%84%8F%200a59b/Untitled%203.png)

그 기능을 수행하는 코드를 짜는 것은 쉽습니다. 위 그림처럼 “GetParameterValueByName” 노드를 가져오고, parameterName 에 “Volume” 을 입력해 줍니다. 결과도 잘 도출 됩니다.

## 프로젝트의 모든 벽체의 볼륨을 산출하는 코드

첫번째 프로그램을 만들고 나니, 한꺼번에 여러개의 벽체를 불러와서 체적을 산출하고 싶어집니다.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%A9%20%E1%84%8F%200a59b/Untitled%204.png)

먼저 다수의 벽체를 불러오는 것 부터 시작해봅시다. 그림에서 왼쪽의 두 노드처럼, 카테고리를 불러오고, 그 카테고리의 모든 객체를 불러오는 코드를 짭니다. 그러면 결과값이 “Select Model Element” 노드의 결과와는 다르게 리스트로 불러와 집니다. 추상화의 기본 원칙은 이것입니다.

- input 값을 단일 개체에서 리스트로 만들기

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%A9%20%E1%84%8F%200a59b/Untitled%205.png)

리스트로 받아온 값을  “GetParameterValueByName” 노드에 연결해 봅니다.

원래 하나의 개체를 처리하는 것과 리스트를 처리하는 코드는 달라야 합니다.

순회문을 적용해야 하는 것이죠.

그런데, 다이나모 기본 노드의 대부분은

단일 객체가 재료로 들어왔을 때와, 리스트가 재료로 들어왔을 때를 구분해서,

알아서 내부에서 순회문을 적용합니다.

따라서 코드를 추가적으로 수정할 필요도 없이 정상 작동합니다. 결과는 당연히 리스트로 반환 되겠죠?

## 프로젝트의 모든 벽체의 볼륨과 표면적, 길이를 산출하는 코드

사람의 욕심은 끝이 없습니다. 이번에는 벽체의 체적값도 얻고, 표면적과 길이도 산출하고 싶어집니다.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%A9%20%E1%84%8F%200a59b/Untitled%206.png)

- input 값을 단일 개체에서 리스트로 만들기

상기의 원칙을 적용해서, parameterName에 들어갈 매개변수 이름을 리스트로 만들어줍니다.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%A9%20%E1%84%8F%200a59b/Untitled%207.png)

한가지 주의 할 것은, 방금 전 위에서 만들었던 리스트를 parameterName에 바로 연결하지 않습니다.

연결하지 않고 그냥 두면 위쪽에 보이는 코드는,

어떤 이름을 재료로 받으면, 그 이름에 해당하는 매개변수 값을 반환하는 하나의 함수가 됩니다.

반환 값이  ‘Function’이라고 적인것이 보이시죠?

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%A9%20%E1%84%8F%200a59b/Untitled%208.png)

List.Map이라는 노드를 불러옵니다. 그다음에는

아까 아까 만들었던 매개변수 이름들의 리스트를 list 에,

아까 만들었던 함수를 function에 연결합니다.

Map 노드의 역할은 재료로 받은 함수를, 재료로 받은 리스트의 모든 원소에 적용해주는 것입니다.

이러한 함수형 노드에 대한 설명도 추가로 곧 포스팅 하겠습니다.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%A9%20%E1%84%8F%200a59b/Untitled%209.png)

“[List.Map](http://List.Map)” 노드가 반환하는 리스트의 구조는

[

[ 첫번째 벽체의 체적, 두번째 벽체의 체적, ... ] ,

[ 첫번째 벽체들의 면적, 두번째 벽체의 체적, ... ] ,

[ 첫번째 벽체들의 길이, 두번째 벽체의 길이, ... ]

] 

이렇게 되어있습니다.

벽체 하나가 가지는 체적, 면적, 길이를 보기 쉽게 확인해야겠죠?

“List.Transpose” 노드를 연결하면 리스트의 구조가 (엑셀에서 말하는) 행과 열이 바뀌게 됩니다.

“List.Transpose” 노드도 나중에 따로 자세히 설명하는 글을 쓸거에요.

최종 결과값을 보면

[

[ 첫번째 벽체의 체적, 첫번째 벽체의 면적, 첫번째 벽체의 길이 ],

[ 두번째 벽체의 체적, 두번째 벽체의 면적, 두번째 벽체의 길이 ],

...

]

이러한 형식으로 잘 정렬되어 반환되는 것을 볼 수 있습니다.

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%A9%20%E1%84%8F%200a59b/Untitled%2010.png)

다 만든 코드의 전체 모습은 이렇습니다. 똑같이 따라해 보세요.

## 결론

![Untitled](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%A9%20%E1%84%8F%200a59b/Untitled%2011.png)

1번, 2번, 3번 의 코드로 갈 수록 추상화 수준이 높아지도록 해봤습니다.

범용적으로 동작하는 프로그램을 만들기 위해서는 이러한 단계를 한층 더 높은 수준으로 몇단계는 더 거쳐야 합니다.

하지만 객체 하나를 다루는 코드를 기반으로, 자꾸 추상화의 정도를 높여가는 연습을 몇번 반복하면

다이나모를 활용하는 데 필요한 정도는 금방 할 수 있습니다. 많이 연습해 보시길 추천합니다.