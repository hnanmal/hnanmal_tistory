# Dynamo로 풀어보자-백준 9498번(시험 성적)

# 시험점수 구간 판별?

시험 점수라는 정수 형태의 스펙트럼을 구간 별로 나누어 판별하는 로직이 필요한 문제입니다.

처음에 막막할 수 있지만, 다이나모 로도 굉장히 간단한 구성으로 해결되는 문제입니다.

# 문제 및 입력 조건

[9498번: 시험 성적](https://www.acmicpc.net/problem/9498)

![Untitled](Dynamo%E1%84%85%E1%85%A9%20%E1%84%91%E1%85%AE%E1%86%AF%E1%84%8B%E1%85%A5%E1%84%87%E1%85%A9%E1%84%8C%E1%85%A1-%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8C%E1%85%AE%E1%86%AB%209498%E1%84%87%E1%85%A5%E1%86%AB(%E1%84%89%E1%85%B5%E1%84%92%E1%85%A5%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8)%2085aefbeaa0ca40f6a10a406290f96f98/Untitled.png)

# 다이나모 풀이

전체 풀이는 하기와 같습니다.

![시험 성적_2022-12-24_05-40-20.png](Dynamo%E1%84%85%E1%85%A9%20%E1%84%91%E1%85%AE%E1%86%AF%E1%84%8B%E1%85%A5%E1%84%87%E1%85%A9%E1%84%8C%E1%85%A1-%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8C%E1%85%AE%E1%86%AB%209498%E1%84%87%E1%85%A5%E1%86%AB(%E1%84%89%E1%85%B5%E1%84%92%E1%85%A5%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8)%2085aefbeaa0ca40f6a10a406290f96f98/%25EC%258B%259C%25ED%2597%2598_%25EC%2584%25B1%25EC%25A0%2581_2022-12-24_05-40-20.png)

## 입력부

![Untitled](Dynamo%E1%84%85%E1%85%A9%20%E1%84%91%E1%85%AE%E1%86%AF%E1%84%8B%E1%85%A5%E1%84%87%E1%85%A9%E1%84%8C%E1%85%A1-%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8C%E1%85%AE%E1%86%AB%209498%E1%84%87%E1%85%A5%E1%86%AB(%E1%84%89%E1%85%B5%E1%84%92%E1%85%A5%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8)%2085aefbeaa0ca40f6a10a406290f96f98/Untitled%201.png)

먼저 성적을 판별할 학생의 점수를 코드 블럭으로 입력 받게 됩니다.

백준 사이트에 예시 입력 이외에도, 여러가지 점수를 기입하여 테스트 케이스를 만들어 둡니다.

## 점수 판별 로직 - 기준값들과의 비교

문제의 설명에는 “90 ~ 100점은 A, 80 ~ 89점은 B, 70 ~ 79점은 C, 60 ~ 69점은 D, 나머지 점수는 F” 라고 되어있습니다. 잘 생각해보면 점수 스펙트럼을 구분하는 기준값들이 90점, 80점, 70점, 60점 임을 알 수 있습니다.

![Untitled](Dynamo%E1%84%85%E1%85%A9%20%E1%84%91%E1%85%AE%E1%86%AF%E1%84%8B%E1%85%A5%E1%84%87%E1%85%A9%E1%84%8C%E1%85%A1-%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8C%E1%85%AE%E1%86%AB%209498%E1%84%87%E1%85%A5%E1%86%AB(%E1%84%89%E1%85%B5%E1%84%92%E1%85%A5%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8)%2085aefbeaa0ca40f6a10a406290f96f98/Untitled%202.png)

따라서 위 그림과 같이

기준값을 작은 크기 부터로 줄 세워 부여하고,

 “<”노드를 통해, 학생의 점수가 기준값들보다 큰지 작은지를 비교하면 참 거짓값이 좌르륵 나오게 됩니다.

그런데 크기 순서대로 기준값이 정렬되어 있기 때문에, 

학생이 가장 낮은 첫 번째 점수 기준을 통과 했는가? 네.

학생이 두 번째 점수 기준을 통과 했는가? 네. 

학생이 세 번째 점수 기준을 통과 했는가? 아니오.

학생이 네 번째 점수 기준을 통과 했는가? 아니오.

와 같은 의미인 데이터가 됩니다.

고로 이 학생은 2번째 기준 까지만 통과한 것이 됩니다.

그럼 주어진 리스트에서 true의 개수를 세서 반환해주는 노드가 필요하겠군요.

![Untitled](Dynamo%E1%84%85%E1%85%A9%20%E1%84%91%E1%85%AE%E1%86%AF%E1%84%8B%E1%85%A5%E1%84%87%E1%85%A9%E1%84%8C%E1%85%A1-%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8C%E1%85%AE%E1%86%AB%209498%E1%84%87%E1%85%A5%E1%86%AB(%E1%84%89%E1%85%B5%E1%84%92%E1%85%A5%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8)%2085aefbeaa0ca40f6a10a406290f96f98/Untitled%203.png)

이렇게 해주면 됩니다. 마지막에 String from Object 노드를 붙여서 숫자를 글자로 만들어준 이유는 잠시 뒤에 나옵니다.

## 점수 판별 로직 - 기준을 통과한 횟수와 등급표의 관계

![Untitled](Dynamo%E1%84%85%E1%85%A9%20%E1%84%91%E1%85%AE%E1%86%AF%E1%84%8B%E1%85%A5%E1%84%87%E1%85%A9%E1%84%8C%E1%85%A1-%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8C%E1%85%AE%E1%86%AB%209498%E1%84%87%E1%85%A5%E1%86%AB(%E1%84%89%E1%85%B5%E1%84%92%E1%85%A5%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8)%2085aefbeaa0ca40f6a10a406290f96f98/Untitled%204.png)

이제 몇 번 통과하면, 등급이 몇이 나오는 지에 대한 매칭 기준만 만들어 두면 됩니다.

위의 그림처럼 4번 통과하면 A, 3번 통과하면 B 등.. 의 대응관계를 딕셔너리 형태로 만들어 봅시다.

다만, 다이나모의 딕셔너리 노드는 key 값으로 문자열만 받을 수 있게 되어있으므로, 숫자들을 문자로 변환하여 key에 대입해줍니다.

![Untitled](Dynamo%E1%84%85%E1%85%A9%20%E1%84%91%E1%85%AE%E1%86%AF%E1%84%8B%E1%85%A5%E1%84%87%E1%85%A9%E1%84%8C%E1%85%A1-%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8C%E1%85%AE%E1%86%AB%209498%E1%84%87%E1%85%A5%E1%86%AB(%E1%84%89%E1%85%B5%E1%84%92%E1%85%A5%E1%86%B7%20%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8)%2085aefbeaa0ca40f6a10a406290f96f98/Untitled%205.png)

이제 마무리만 남았네요. 위쪽은 점수 기준 통과 회수에 따른 등급 표이고, 아래쪽은 학생이 실제로 점수 기준을 몇회 통과했는지를 문자로 반환하고 있습니다. 

이제 “Dictionary.ValueAtKey” 노드를 써서, 위쪽에 딕셔너리 중 “2”라는 키에 대응되는 밸류를 찾아주기만 하면 됩니다.

아주 쉽게 학생의 점수 등급이 C라는 것을 알 수 있었네요.

# 결론

다른 언어였다면 이 문제를 풀 때 if, else 구문으로 접근을 했을 테지만, 다이나모에서는 if 노드를 사용해서 문제에 접근하게 되면 논리는 간단하나, 알고리즘에 참여하게 되는 노드들이 너무 많아진다는 단점이 있습니다. 복잡해지면 나중에 코드 작성자도 내용 파악이 안되기 십상입니다.

대부분의 if 문을 통한 분기 제어 흐름은, 사실은 딕셔너리 형태로 표현될 수 있는 데이터 타입의 다른 모습이라는 것을 기억하기만 해도 훨씬 효율적인 코드를 짤 수 있을 것이라 생각합니다.