# 신선한 오렌지를 먹고싶어서 Dynamo로 그려버렸습니다

---

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled.png)

밤중에 먹는 과일이 그 맛이 참 달콤하죠. 오렌지를 까먹다가 보니 불현듯 다이나모로도 오렌지를 만들면 재미있겠다 싶어서 한밤중에 홀린듯이 키보드와 마우스를 잡았습니다.

다이나모는 일반적인 데이터 처리도 충분히 가능하지만, 형상을 그려내고 조작하는 데에 강점이 있는 비주얼 프로그래밍 툴입니다.

그러니 쓸데없는 짓이긴 하지만 오렌지의 단면을 만드는 법을 한번 포스팅하면 사람들이 관심도 가질 것 같고, 생각보다 어렵지 않은 사용법을 보고 마음속 진입장벽도 좀 낮출 수 있지 않을까요?

뭐 만들때는 재미있었습니다. ㅎㅎㅎ

## 다이나모로 오렌지를 만들땐 6단계가 필요하다.

코딩을 하고 각 코드의 역할 별로 그룹을 짓다보니 총 6단계로 구성된 코드가 되었습니다.

![Home_2022-04-02_12-10-54.png](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Home_2022-04-02_12-10-54.png)

전체 코드의 모습은 위와 같습니다.

단계별로 확대해 보여드리면서 다시 한번 보여드릴게요.

### 1. 오렌지 테두리 만들기

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%201.png)

가장 먼저 할 일은 오렌지 단면의 테두리를 만들어주는 일입니다.

**Circle.ByCenterPointRadius** 노드를 사용하면 입력한 숫자를 반지름으로 하는 원을 그려줍니다.

먼저 바깥 테두리를 반지름이 11인 원으로 만들어 주고, **Curve.Offset** 노드를 이용하여 1만큼 안쪽으로 지름이 줄어든 원을 마저 그려줍니다.

그림처럼 2개의 동심원이 생겼죠?

### 2. 안쪽 테두리를 10등분하는 점 찾기

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%202.png)

이제 안쪽 테두리를 기준으로 오렌지 과육을 만들기 위한 준비를 해보겠습니다.

오렌지 과육이 배치되는 모양은 꼭 자전거 바퀴처럼 생겼습니다.

그래서 일정한 간격으로 안쪽의 원을 분할해야 합니다.

그러기 위해서는 먼저 분할의 기준이 되는 포인트를 만들어두는게 편하겠죠?

제가 먹던 오렌지의 과육개수를 세어보니까 10개더라고요. 

저도 다이나모 오렌지의 안쪽 테두리를 10등분 해보려고 합니다.

먼저 **Curve.PointAtParameter**라는 노드를 설명해야 하는데요. 

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%203.png)

그림처럼 길이가 1인 선분을 하나 만들었어요.

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%204.png)

이 선분을 **Curve.PointAtParameter**노드에 연결하고, 인자 값으로 0을 부여하면, 그림처럼 선분의 시작부분에 점을 하나 만듭니다.

그러면 1을 연결하면 어떻게 될까요?

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%205.png)

네, 눈치 채신것 처럼 1을 대입하면 선분의 끝부분에 점을 만들게 됩니다.

그러면 0.5를 집어넣으면 중간점이 나오겠죠?

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%206.png)

순조롭군요 ㅎㅎ

이제 0과 0.5 그리고 1을 리스트로 만들어서 한꺼번에 전달하면?

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%207.png)

선분의 길이를 1로 가정했을 때, 입력받은 숫자들의 위치가 되는 포인트를 하나씩 반환해서, 총 3개의 점이 나옵니다.

즉 0~1 범위의 숫자를 n개 넣어주면, 그에 해당하는 포인트도 n개 도출되는 노드인 것이죠.

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%202.png)

그럼 이제 Curve.PointAtParameter노드의  앞에 있는 **코드블럭**과 **List.DropItems**를 해석해볼까요?

코드블럭에 적힌 “0..1..#11” 이라는 코드는 0부터 1까지의 수를 동일한 간격으로 나누어서 총 11개의 숫자가 리스트로 나오도록 해줍니다.

그런데, 원은 선분과 다르게, 시작점과 끝점이 동일한 도형이잖아요?

그래서 **List.DropItems**노드로 중복되는 점을 만들어주는 마지막 원소를 제외해야, 원하는 결과를 얻을 수 있는 param 목록이 10개 원소를 갖는 리스트로 완성되고, 이에 해당하는 점들도 10개로 반환되는 것이죠.

### 3. 점을 기준으로 안쪽 테두리 커브를 10등분하기

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%208.png)

앞에서 원을 동일한 간격으로 나누는 기준이 될 점 10개를 확보했으니 그 점들을 기분으로 오렌지의 안쪽테두리를 10개의 커브로 나누어주면 되겠네요!

그 역할을 해주는 노드가 딱 있습니다. 이름은 바로 **Curve.SplitByPoints**라는 노드에요.

이 노드는 인자로 커브와 커브위의 점을 받아서 점을 기준으로 분할해 줍니다.

위 그림에서 분할한 결과의 첫번째만 보이도록 설정하니까 점 2개를 이어주는 호가 생긴 것이 보이죠?

### 4. 오렌지 과육 구분선 만들기

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%209.png)

이제 원의 중심에서 안쪽테두리 분할 점까지를 선분으로 만들어서 과육들을 구분해봅시다.

**Line.ByStartPointEndPoint**노드를 쓰면 되는데, 사용법은 쉽습니다.

선분의 시작이 될 점을 startPoint 포트로 연결하고, 선분의 끝이 될 점을 endPoint로 연결하기만 하면 끝입니다.

노드를 실행한 결과는 화면에 보이는 것과 같겠죠? 이 선분들을 ‘과육구분선’이라 부르겠습니다.

### 5. 분할된 안쪽 테두리선과 과육 구분선 세트만들기

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%2010.png)

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%2011.png)

이제 기준이 되는 형상은 다 만들어졌습니다. 남은건 6단계를 수행하기 위해서 과육 한덩이를 이루는 선들을 합쳐서 폴리커브로 만들어 주는 일 뿐입니다.

로직을 설명하자면

하나의 호가 접하는 모든 ‘과육구분선’들을 찾아서 그룹을 만들어 주는 것 입니다.

접하는 선분을 찾는 과정은 **Geometry.DoesIntersect**노드와 **List.FilterByBoolMask**노드를 활용하면 되겠죠?

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%2012.png)

구체적인 연산 과정은 위의 그림으로 이해하시면 됩니다.

(**Geometry.DoesIntersect**노드의 @L1 세팅이 있어야 Curve 요소 하나마다 Line 요소 전체를 대입하여 판별한 결과를 모아서 보여줍니다. 리스트 레벨 구조를 다르게 하여 직접 결과값이 달라지는 것을 실습해 보시면 더 이해하기 쉽습니다.)

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%2013.png)

그룹을 짓고 나면 위의 그림처럼 피자모양의 폴리라인을 만들 수 있습니다.

### 6. 과육 폴리커브 fillet(모따기)

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%2014.png)

**PolyCurve.Fillet**노드를 이용하면 폴리라인의 모든 각을 둥글게 모따기 처리 할 수 있습니다.

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%2015.png)

Fillet 노드를 사용할 때는 주의할 점이 있는데요.

폴리커브 시작점에 대해 오른쪽방향으로 모따기를 하는 것이 기본설정이라는 것입니다.

그래서 만약 폴리커브의 방향이 반대라면 모따기 실행이 되지 않습니다.

따라서 맨 왼쪽에 **PolyCurve.Fillet**노드 이후의 코드들은 예외사항을 처리하는 코드들로 이해하면 되고, 직접 따라해보면 바로 이해하실 수 있을거에요.

쉽게말하면 한번 모따기를 해서 모따기가 되지 않은 것들을 따로 모아서, 반대방향 옵션을 주고 마저 모따기를 완료한다고 이해하시면 됩니다.

## 완성된 오렌지

![Untitled](%E1%84%89%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB%20%207f30b/Untitled%2016.png)

먹음직스러운 오렌지가 과육을 드러내고 있군요.

오렌지 단면을 만들어 내는 코드는 아래에 첨부해 둘테니, 다운받아서 똑같이 코드를 짜보는 연습을 해보시기 바랍니다.

생각보다 재미있을지도?